#!/bin/bash

# Stop script on any error
set -e

# =================================================================
# Project Overwatch - Zero-Downtime Deployment Script
# v3.1 - With enhanced safety and self-documenting rollback
#
# This script uses a blue-green deployment strategy.
# 1. It creates a new 'release' directory for the new code.
# 2. It installs dependencies, builds, and migrates the DB.
# 3. It then atomically switches a 'current' symlink to the new release.
# 4. Finally, it reloads the apps with PM2 for zero downtime.
# =================================================================

# --- Configuration ---
# Colors for output
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m' # No Color

# Directory structure
RELEASES_DIR="releases"
SHARED_DIR="shared"
CURRENT_SYMLINK="current"
RELEASES_TO_KEEP=3

# Database location (stored outside of releases to persist)
DATA_DIR="/root/data"
DB_FILE="${DATA_DIR}/pow.db"
DB_PATH="file:${DB_FILE}"

# Port for the dashboard
PORT="41729"

echo -e "${BLUE}==================================================${NC}"
echo -e "${BLUE}   Project Overwatch Zero-Downtime Deployer   ${NC}"
echo -e "${BLUE}==================================================${NC}"

# --- Pre-flight Checks ---
# Check for required commands
if ! command -v unzip &> /dev/null; then
    echo -e "${RED}[ERROR] 'unzip' command not found. Please install it to proceed.${NC}"
    exit 1
fi
if ! command -v npm &> /dev/null; then
    echo -e "${RED}[ERROR] 'npm' command not found. Please install Node.js and npm.${NC}"
    exit 1
fi

# Check for Archive.zip
if [ ! -f "Archive.zip" ]; then
    echo -e "${RED}[ERROR] Archive.zip not found.${NC}"
    echo "Please upload your project files as Archive.zip before running."
    exit 1
fi

# Check for ecosystem.config.js
if [ ! -f "ecosystem.config.js" ]; then
    echo -e "${RED}[ERROR] ecosystem.config.js not found.${NC}"
    echo "Please ensure ecosystem.config.js exists in the project root before running."
    exit 1
fi

# Install PM2 if missing
if ! command -v pm2 &> /dev/null; then
    echo -e "${YELLOW}PM2 not found. Installing globally...${NC}"
    sudo npm install -g pm2
fi

# --- 1. Setup Directories ---
echo -e "${YELLOW}[1/8] Setting up directories...${NC}"
mkdir -p ${RELEASES_DIR}
mkdir -p ${SHARED_DIR}
mkdir -p ${DATA_DIR}

# Create a new directory for this release
RELEASE_NAME=$(date +"%Y%m%d%H%M%S")
NEW_RELEASE_DIR="${RELEASES_DIR}/${RELEASE_NAME}"
mkdir -p "${NEW_RELEASE_DIR}"
echo -e "New release directory: ${GREEN}${NEW_RELEASE_DIR}${NC}"

# --- 2. Unpack and Prepare ---
echo -e "${YELLOW}[2/8] Unzipping project files...${NC}"
unzip -o -q Archive.zip -d "${NEW_RELEASE_DIR}"

# Handle case where user zips the parent folder instead of the contents
if [ -d "${NEW_RELEASE_DIR}/p-ow" ]; then
    echo "Note: Nested 'p-ow' directory found. Moving contents up."
    # Use shopt dotglob to include hidden files, or use find (more compatible)
    shopt -s dotglob 2>/dev/null || true
    mv "${NEW_RELEASE_DIR}/p-ow/"* "${NEW_RELEASE_DIR}/" 2>/dev/null || true
    shopt -u dotglob 2>/dev/null || true
    rm -rf "${NEW_RELEASE_DIR}/p-ow"
fi
echo -e "${GREEN}Files extracted successfully.${NC}"

# --- 3. Environment Configuration ---
echo -e "${YELLOW}[3/8] Configuring environment...${NC}"
SHARED_ENV_FILE="${SHARED_DIR}/.env"

if [ ! -f "${SHARED_ENV_FILE}" ]; then
    echo -e "${YELLOW}No existing .env file found. Starting first-time setup...${NC}"
    
    read -p "Discord Bot Token: " DISCORD_BOT_TOKEN
    read -p "Discord Client ID: " CLIENT_ID
    read -p "Discord Guild ID: " GUILD_ID
    read -p "Clerk Secret Key: " CLERK_SECRET_KEY
    read -p "Clerk Publishable Key: " NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY
    read -p "Roblox API Key (Open Cloud): " ROBLOX_API_KEY
    read -p "Discord Punishment Webhook URL: " DISCORD_PUNISHMENT_WEBHOOK
    read -p "Mistral API Key: " MISTRAL_API_KEY
    read -p "Garmin API Key: " GARMIN_API_KEY
    read -p "PostHog Project API Key: " POSTHOG_KEY
    
    NEXTAUTH_SECRET=$(openssl rand -base64 32)
    INTERNAL_SECRET=$(openssl rand -base64 32)
    VISION_JWT_SECRET=$(openssl rand -base64 32)
    # VISION_HMAC_SECRET is hardcoded to match the Vision desktop app
    VISION_HMAC_SECRET="pow-vision-hmac-secret-2024"
    
    # Write to the shared .env file
    cat > "${SHARED_ENV_FILE}" <<EOL
# Generated by deploy.sh
DATABASE_URL="${DB_PATH}"
PORT="${PORT}"

# Discord Config
DISCORD_TOKEN="${DISCORD_BOT_TOKEN}"
DISCORD_BOT_TOKEN="${DISCORD_BOT_TOKEN}"
CLIENT_ID="${CLIENT_ID}"
GUILD_ID="${GUILD_ID}"
DISCORD_PUNISHMENT_WEBHOOK="${DISCORD_PUNISHMENT_WEBHOOK}"

# Internal Secrets
INTERNAL_SYNC_SECRET="${INTERNAL_SECRET}"
VISION_JWT_SECRET="${VISION_JWT_SECRET}"
VISION_HMAC_SECRET="${VISION_HMAC_SECRET}"

# Roblox Config
ROBLOX_API_KEY="${ROBLOX_API_KEY}"

# Dashboard Config
DASHBOARD_URL="http://127.0.0.1:${PORT}"
NEXT_PUBLIC_APP_URL="https://pow.ciankelly.xyz"
NEXTAUTH_URL="https://pow.ciankelly.xyz"
NEXTAUTH_SECRET="${NEXTAUTH_SECRET}"

# Clerk Auth
CLERK_SECRET_KEY="${CLERK_SECRET_KEY}"
NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY="${NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY}"

# AI Services
MISTRAL_API_KEY="${MISTRAL_API_KEY}"

# External APIs
GARMIN_API_URL="https://garminapi.ciankelly.xyz"
GARMIN_API_KEY="${GARMIN_API_KEY}"

# PostHog Analytics
NEXT_PUBLIC_POSTHOG_KEY="${POSTHOG_KEY}"
NEXT_PUBLIC_POSTHOG_HOST="https://eu.i.posthog.com"

# Legal
NEXT_PUBLIC_LEGAL_URL="https://lacrp.ciankelly.xyz/project-overwatch-legal-documents"
EOL
    echo -e "${GREEN}New environment file created and saved in '${SHARED_DIR}/'.${NC}"
else
    echo -e "${GREEN}Existing environment file found in '${SHARED_DIR}/'.${NC}"
    # Ensure DATABASE_URL and PORT are up-to-date (Linux-compatible sed)
    if grep -q "DATABASE_URL=" "${SHARED_ENV_FILE}"; then
        sed -i "s|^DATABASE_URL=.*|DATABASE_URL=\"${DB_PATH}\"|" "${SHARED_ENV_FILE}"
    else
        echo "DATABASE_URL=\"$DB_PATH\"" >> "${SHARED_ENV_FILE}"
    fi
    if ! grep -q "PORT=" "${SHARED_ENV_FILE}"; then
        echo "PORT=\"$PORT\"" >> "${SHARED_ENV_FILE}"
    fi
    
    # Check for missing secrets and prompt if needed
    echo "Checking for missing environment variables..."
    
    # Auto-generated secrets
    if ! grep -q "VISION_JWT_SECRET=" "${SHARED_ENV_FILE}"; then
        echo "Adding missing VISION_JWT_SECRET..."
        echo "VISION_JWT_SECRET=\"$(openssl rand -base64 32)\"" >> "${SHARED_ENV_FILE}"
    fi
    if ! grep -q "NEXTAUTH_SECRET=" "${SHARED_ENV_FILE}"; then
        echo "Adding missing NEXTAUTH_SECRET..."
        echo "NEXTAUTH_SECRET=\"$(openssl rand -base64 32)\"" >> "${SHARED_ENV_FILE}"
    fi
    if ! grep -q "INTERNAL_SYNC_SECRET=" "${SHARED_ENV_FILE}"; then
        echo "Adding missing INTERNAL_SYNC_SECRET..."
        echo "INTERNAL_SYNC_SECRET=\"$(openssl rand -base64 32)\"" >> "${SHARED_ENV_FILE}"
    fi
    
    # VISION_HMAC_SECRET must match the hardcoded value in the Vision desktop app
    CORRECT_HMAC="pow-vision-hmac-secret-2024"
    if ! grep -q "VISION_HMAC_SECRET=" "${SHARED_ENV_FILE}"; then
        echo "Adding missing VISION_HMAC_SECRET..."
        echo "VISION_HMAC_SECRET=\"${CORRECT_HMAC}\"" >> "${SHARED_ENV_FILE}"
    elif ! grep -q "VISION_HMAC_SECRET=\"${CORRECT_HMAC}\"" "${SHARED_ENV_FILE}"; then
        echo "Updating VISION_HMAC_SECRET to match Vision app..."
        sed -i "s|^VISION_HMAC_SECRET=.*|VISION_HMAC_SECRET=\"${CORRECT_HMAC}\"|" "${SHARED_ENV_FILE}"
    fi
    
    # Discord Config
    if ! grep -q "DISCORD_TOKEN=" "${SHARED_ENV_FILE}" && ! grep -q "DISCORD_BOT_TOKEN=" "${SHARED_ENV_FILE}"; then
        read -p "Missing Discord Bot Token: " VAL
        echo "DISCORD_TOKEN=\"$VAL\"" >> "${SHARED_ENV_FILE}"
        echo "DISCORD_BOT_TOKEN=\"$VAL\"" >> "${SHARED_ENV_FILE}"
    fi
    if ! grep -q "CLIENT_ID=" "${SHARED_ENV_FILE}"; then
        read -p "Missing Discord Client ID: " VAL
        echo "CLIENT_ID=\"$VAL\"" >> "${SHARED_ENV_FILE}"
    fi
    if ! grep -q "GUILD_ID=" "${SHARED_ENV_FILE}"; then
        read -p "Missing Discord Guild ID: " VAL
        echo "GUILD_ID=\"$VAL\"" >> "${SHARED_ENV_FILE}"
    fi
    if ! grep -q "DISCORD_PUNISHMENT_WEBHOOK=" "${SHARED_ENV_FILE}"; then
        read -p "Missing Discord Punishment Webhook URL: " VAL
        echo "DISCORD_PUNISHMENT_WEBHOOK=\"$VAL\"" >> "${SHARED_ENV_FILE}"
    fi
    
    # Clerk Auth
    if ! grep -q "CLERK_SECRET_KEY=" "${SHARED_ENV_FILE}"; then
        read -p "Missing Clerk Secret Key: " VAL
        echo "CLERK_SECRET_KEY=\"$VAL\"" >> "${SHARED_ENV_FILE}"
    fi
    if ! grep -q "NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=" "${SHARED_ENV_FILE}"; then
        read -p "Missing Clerk Publishable Key: " VAL
        echo "NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=\"$VAL\"" >> "${SHARED_ENV_FILE}"
    fi
    
    # External API Keys
    if ! grep -q "ROBLOX_API_KEY=" "${SHARED_ENV_FILE}"; then
        read -p "Missing Roblox API Key (Open Cloud): " VAL
        echo "ROBLOX_API_KEY=\"$VAL\"" >> "${SHARED_ENV_FILE}"
    fi
    if ! grep -q "MISTRAL_API_KEY=" "${SHARED_ENV_FILE}"; then
        read -p "Missing Mistral API Key: " VAL
        echo "MISTRAL_API_KEY=\"$VAL\"" >> "${SHARED_ENV_FILE}"
    fi
    if ! grep -q "GARMIN_API_KEY=" "${SHARED_ENV_FILE}"; then
        read -p "Missing Garmin API Key: " VAL
        echo "GARMIN_API_KEY=\"$VAL\"" >> "${SHARED_ENV_FILE}"
    fi
    if ! grep -q "NEXT_PUBLIC_POSTHOG_KEY=" "${SHARED_ENV_FILE}"; then
        read -p "Missing PostHog Project API Key: " VAL
        echo "NEXT_PUBLIC_POSTHOG_KEY=\"$VAL\"" >> "${SHARED_ENV_FILE}"
    fi
    
    # Auto-set URLs if missing
    if ! grep -q "DASHBOARD_URL=" "${SHARED_ENV_FILE}"; then
        echo "DASHBOARD_URL=\"http://127.0.0.1:${PORT}\"" >> "${SHARED_ENV_FILE}"
    fi
    if ! grep -q "NEXT_PUBLIC_APP_URL=" "${SHARED_ENV_FILE}"; then
        echo "NEXT_PUBLIC_APP_URL=\"https://pow.ciankelly.xyz\"" >> "${SHARED_ENV_FILE}"
    fi
    if ! grep -q "NEXTAUTH_URL=" "${SHARED_ENV_FILE}"; then
        echo "NEXTAUTH_URL=\"https://pow.ciankelly.xyz\"" >> "${SHARED_ENV_FILE}"
    fi
    if ! grep -q "GARMIN_API_URL=" "${SHARED_ENV_FILE}"; then
        echo "GARMIN_API_URL=\"https://garminapi.ciankelly.xyz\"" >> "${SHARED_ENV_FILE}"
    fi
    if ! grep -q "NEXT_PUBLIC_POSTHOG_HOST=" "${SHARED_ENV_FILE}"; then
        echo "NEXT_PUBLIC_POSTHOG_HOST=\"https://eu.i.posthog.com\"" >> "${SHARED_ENV_FILE}"
    fi
    if ! grep -q "NEXT_PUBLIC_LEGAL_URL=" "${SHARED_ENV_FILE}"; then
        echo "NEXT_PUBLIC_LEGAL_URL=\"https://lacrp.ciankelly.xyz/project-overwatch-legal-documents\"" >> "${SHARED_ENV_FILE}"
    fi
    
    echo -e "${GREEN}All required environment variables verified.${NC}"
fi

# Verify DATABASE_URL points to the correct file
echo "Verifying DATABASE_URL in .env..."
if grep -q "DATABASE_URL=\"file:/root/data/pow.db\"" "${SHARED_ENV_FILE}"; then
    echo -e "${GREEN}DATABASE_URL is correctly set to: file:/root/data/pow.db${NC}"
else
    echo -e "${RED}WARNING: DATABASE_URL may not be correct. Current value:${NC}"
    grep "DATABASE_URL" "${SHARED_ENV_FILE}" || echo "DATABASE_URL not found!"
    echo -e "${YELLOW}Fixing DATABASE_URL...${NC}"
    sed -i "s|^DATABASE_URL=.*|DATABASE_URL=\"file:/root/data/pow.db\"|" "${SHARED_ENV_FILE}"
fi

# Copy the shared .env to ALL required locations in the new release
echo "Copying .env to all required locations..."
cp "${SHARED_ENV_FILE}" "${NEW_RELEASE_DIR}/.env"
cp "${SHARED_ENV_FILE}" "${NEW_RELEASE_DIR}/dashboard/.env"
cp "${SHARED_ENV_FILE}" "${NEW_RELEASE_DIR}/dashboard/.env.local"
cp "${SHARED_ENV_FILE}" "${NEW_RELEASE_DIR}/bot/.env"
echo -e "${GREEN}Copied .env to: root, dashboard, dashboard/.env.local, and bot${NC}"

# --- 4. Install Dependencies ---
echo -e "${YELLOW}[4/8] Installing dependencies (this may take a moment)...${NC}"

# Store the project root before changing directories
PROJECT_ROOT=$(pwd)

cd "${PROJECT_ROOT}/${NEW_RELEASE_DIR}"
npm install --silent --production=false 2>&1 | tail -5 || true
echo "Installing Dashboard dependencies..."
cd "${PROJECT_ROOT}/${NEW_RELEASE_DIR}/dashboard" && npm install --silent --production=false 2>&1 | tail -5 || true
echo "Installing Bot dependencies..."
cd "${PROJECT_ROOT}/${NEW_RELEASE_DIR}/bot" && npm install --silent --production=false 2>&1 | tail -5 || true
cd "${PROJECT_ROOT}"
echo -e "${GREEN}All dependencies installed.${NC}"

# --- 5. Database Setup ---
echo -e "${YELLOW}[5/8] Setting up database...${NC}"

# PROJECT_ROOT was already set in step 4

# CRITICAL: Set DATABASE_URL explicitly for all prisma commands
export DATABASE_URL="file:/root/data/pow.db"
echo "DATABASE_URL set to: ${DATABASE_URL}"

# Check if the database file exists
if [ ! -f "${DB_FILE}" ]; then
    echo -e "${YELLOW}No production database found at ${DB_FILE}.${NC}"
    echo -e "${YELLOW}Creating new database with schema...${NC}"
    # Only for FIRST TIME deployment - create empty database
    cd "${PROJECT_ROOT}/${NEW_RELEASE_DIR}/dashboard"
    npx prisma migrate deploy || npx prisma db push --skip-generate
    echo -e "${GREEN}New database created successfully.${NC}"
else
    echo -e "${GREEN}Existing database found at ${DB_FILE} ($(ls -lh ${DB_FILE} | awk '{print $5}'))${NC}"
    # NEVER use --accept-data-loss on existing database!
    # Just run migrate deploy to apply any new migrations
    cd "${PROJECT_ROOT}/${NEW_RELEASE_DIR}/dashboard"
    echo "Applying migrations (if any)..."
    npx prisma migrate deploy 2>&1 || {
        echo -e "${YELLOW}No migrations to apply or migration failed - this is usually OK${NC}"
    }
    echo -e "${GREEN}Database setup complete.${NC}"
fi

# Return to project root
cd "${PROJECT_ROOT}"

# Sync prisma schema to bot and generate clients
echo "Syncing Prisma schema to bot..."
PRISMA_SCHEMA="${PROJECT_ROOT}/${NEW_RELEASE_DIR}/dashboard/prisma/schema.prisma"

# Debug: Show what we're looking for
echo "Looking for prisma schema at: ${PRISMA_SCHEMA}"
ls -la "${PROJECT_ROOT}/${NEW_RELEASE_DIR}/" 2>/dev/null || echo "Release dir not found"

if [ -f "${PRISMA_SCHEMA}" ]; then
    mkdir -p "${PROJECT_ROOT}/${NEW_RELEASE_DIR}/bot/prisma"
    cp "${PRISMA_SCHEMA}" "${PROJECT_ROOT}/${NEW_RELEASE_DIR}/bot/prisma/schema.prisma"
    echo "Prisma schema copied to bot."
else
    echo -e "${RED}[ERROR] Prisma schema not found at ${PRISMA_SCHEMA}${NC}"
    echo "Contents of release directory:"
    ls -la "${PROJECT_ROOT}/${NEW_RELEASE_DIR}/"
    if [ -d "${PROJECT_ROOT}/${NEW_RELEASE_DIR}/dashboard" ]; then
        echo "Contents of dashboard directory:"
        ls -la "${PROJECT_ROOT}/${NEW_RELEASE_DIR}/dashboard/"
    fi
    exit 1
fi

echo "Generating Prisma Clients..."
# Explicitly set DATABASE_URL for prisma generate
export DATABASE_URL="file:/root/data/pow.db"
echo "Using DATABASE_URL: ${DATABASE_URL}"

# Verify database file exists
if [ -f "/root/data/pow.db" ]; then
    echo -e "${GREEN}Database file exists at /root/data/pow.db ($(ls -lh /root/data/pow.db | awk '{print $5}'))${NC}"
else
    echo -e "${RED}[ERROR] Database file NOT FOUND at /root/data/pow.db!${NC}"
    echo "This will cause the application to fail. Please restore the database."
    exit 1
fi

cd "${PROJECT_ROOT}/${NEW_RELEASE_DIR}/dashboard" && npx prisma generate
cd "${PROJECT_ROOT}/${NEW_RELEASE_DIR}/bot" && npx prisma generate
cd "${PROJECT_ROOT}"
echo -e "${GREEN}Prisma clients generated.${NC}"

# --- 6. Build Projects ---
echo -e "${YELLOW}[6/8] Building Dashboard project...${NC}"
cd "${PROJECT_ROOT}/${NEW_RELEASE_DIR}/dashboard"
# If build fails, script will exit thanks to 'set -e'
npm run build
echo -e "${GREEN}Dashboard build complete.${NC}"
cd "${PROJECT_ROOT}"

# --- 7. Go Live! ---
echo -e "${YELLOW}[7/8] Activating new release...${NC}"

# Make sure we're in the project root
cd "${PROJECT_ROOT}"

# Create absolute path for symlink
FULL_NEW_RELEASE_PATH="${PROJECT_ROOT}/${NEW_RELEASE_DIR}"

# Atomically switch the 'current' symlink to the new release directory
# Remove old symlink first, then create new one
rm -f "${CURRENT_SYMLINK}"
ln -sfn "${FULL_NEW_RELEASE_PATH}" "${CURRENT_SYMLINK}"

echo -e "Symlink '${CURRENT_SYMLINK}' now points to ${GREEN}${FULL_NEW_RELEASE_PATH}${NC}"

# Verify symlink is correct
echo "Verifying symlink:"
ls -la "${CURRENT_SYMLINK}"

# Use PM2 to restart the apps (delete + start to ensure fresh process)
echo "Restarting applications with PM2..."
pm2 delete all 2>/dev/null || true
pm2 start ecosystem.config.js
pm2 save
echo -e "${GREEN}Applications reloaded successfully! Your new version is LIVE.${NC}"

# --- 8. Cleanup ---
echo -e "${YELLOW}[8/8] Cleaning up old releases...${NC}"
# Find all release directories, sort them by name (timestamp), and keep the newest ones.
OLD_RELEASES=$(ls -r1 "${RELEASES_DIR}" | tail -n +$((${RELEASES_TO_KEEP}+1)))
if [ -n "${OLD_RELEASES}" ]; then
    for release in ${OLD_RELEASES}; do
        echo "Deleting old release: ${RELEASES_DIR}/${release}"
        rm -rf "${RELEASES_DIR}/${release}"
    done
    echo -e "${GREEN}Cleanup complete.${NC}"
else
    echo "No old releases to clean up."
fi

echo -e "${BLUE}==================================================${NC}"
echo -e "${GREEN}   ðŸš€ DEPLOYMENT COMPLETE! ðŸš€   ${NC}"
echo -e "${BLUE}==================================================${NC}"
echo ""
echo "Useful commands:"
echo "  pm2 logs          - View live application logs"
echo "  pm2 status        - Show service status"
echo ""

# =================================================================
# EMERGENCY ROLLBACK INSTRUCTIONS
#
# If the new release is broken, you can quickly roll back.
#
# 1. List previous successful releases:
#    ls -l releases
#
# 2. Pick the timestamp of the last good version (e.g., 20251230120000)
#    and run this command to point 'current' back to it:
#
#    ln -sfn releases/PASTE_TIMESTAMP_HERE current
#
# 3. Reload the apps to switch back to the old code:
#    pm2 reload all
#
# =================================================================
